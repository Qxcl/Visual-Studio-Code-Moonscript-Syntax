/**
 * Promise-based object stream with seamless support for back-pressure and error
 * handling, written in Typescript.
 *
 * Copyright (C) 2015 Martin Poelstra
 * License: MIT
 */
"use strict"; /* istanbul ignore next */ // ignores Typescript's __extend() function
var __extends = (this && this.__extends) || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
};
var ts_promise_1 = require("ts-promise");
var assert = require("assert");
var Transform_1 = require("./Transform");
var util_1 = require("./util");
/**
 * Used when writing to an already-ended stream.
 */
var WriteAfterEndError = (function (_super) {
    __extends(WriteAfterEndError, _super);
    function WriteAfterEndError() {
        _super.call(this, "WriteAfterEndError", "stream already ended");
    }
    return WriteAfterEndError;
}(ts_promise_1.BaseError));
exports.WriteAfterEndError = WriteAfterEndError;
/**
 * Used when read callback(s) have already been attached.
 */
var AlreadyHaveReaderError = (function (_super) {
    __extends(AlreadyHaveReaderError, _super);
    function AlreadyHaveReaderError() {
        _super.call(this, "AlreadyHaveReaderError", "stream already has a reader");
    }
    return AlreadyHaveReaderError;
}(ts_promise_1.BaseError));
exports.AlreadyHaveReaderError = AlreadyHaveReaderError;
/**
 * Default end-handler used in e.g. [[Stream.forEach]].
 * @param err `undefined` in case of normal stream end, or an Error
 * @return Rejected promise in case of an error, void otherwise
 */
function defaultEnder(err) {
    if (err) {
        return ts_promise_1.Promise.reject(err);
    }
}
/**
 * Special internal 'error' value to indicate normal stream end.
 */
var EOF = new Error("eof");
/**
 * Special end-of-stream value, optionally signalling an error.
 */
var Eof = (function () {
    /**
     * Create new end-of-stream value, optionally signalling an error.
     * @param error     Optional Error value
     * @param result Optional final result value of `result()`
     */
    function Eof(error, result) {
        this.error = error;
        this.result = result;
    }
    return Eof;
}());
/**
 * Object stream with seamless support for backpressure, ending and error
 * handling.
 */
var Stream = (function () {
    function Stream() {
        var _this = this;
        /**
         * Writers waiting for `_reader` to retrieve and process their value.
         */
        this._writers = [];
        /**
         * Resolved to a rejection when `abort()` is called.
         */
        this._abortDeferred = ts_promise_1.Promise.defer();
        /**
         * Resolved to the result of calling `_ender`, then the `result` property of
         * the end-of-stream value.
         */
        this._resultDeferred = ts_promise_1.Promise.defer();
        /**
         * Bound callback to be passed as handlers to Promise.then()
         */
        this._pumper = function () { return _this._pump(); };
    }
    /**
     * Write value (or promise for value) to stream.
     *
     * Writer is blocked until the value is read by the read handler passed to
     * `forEach()`, and the value returned by that read handler is resolved.
     *
     * It is an error to write an `undefined` value (as this is a common
     * programming error). Writing a promise for a void is currently allowed,
     * but discouraged.
     *
     * The promise returned by `write()` will be rejected with the same reason if:
     * - the written value is a Thenable that resolves to a rejection
     * - the read handler throws an error or returns a rejected promise
     * It is still possible to write another value after that, or e.g. `end()`
     * the stream with or without an error.
     *
     * @param value Value to write, or promise for it
     * @return Void-promise that resolves when value was processed by reader
     */
    Stream.prototype.write = function (value) {
        if (value === undefined) {
            // Technically, we could allow this, but it's a common programming
            // error to forget to return a value, and it's arguable whether it's
            // useful to have a stream of void's, so let's prevent it for now.
            // NOTE: This behaviour may change in the future
            // TODO: prevent writing a void Thenable too?
            return ts_promise_1.Promise.reject(new TypeError("cannot write void value, use end() to end the stream"));
        }
        var valuePromise = ts_promise_1.Promise.resolve(value);
        var writeDone = ts_promise_1.Promise.defer();
        this._writers.push({
            resolveWrite: writeDone.resolve,
            value: valuePromise,
        });
        this._pump();
        return writeDone.promise;
    };
    /**
     * End the stream, optionally passing an error.
     *
     * Already pending writes will be processed by the reader passed to
     * `forEach()` before passing the end-of-stream to its end handler.
     *
     * The returned promise will resolve after the end handler has finished
     * processing. It is rejected if the end handler throws an error or returns
     * a rejected promise.
     *
     * All calls to `write()` or `end()` after the first `end()` will be
     * rejected with a `WriteAfterEndError`.
     *
     * By default, this stream's `result()` will be resolved when `end()`
     * resolves, or rejected with the error if `end()` is called with an error.
     * It is possible to let this stream's `result()` 'wait' until any upstream
     * streams have completed by e.g. passing that upstream's `result()` as the
     * second argument to `end()`.
     *
     * @param  error Optional Error to pass to `forEach()` end handler
     * @param  result Optional promise that determines final value of `result()`
     * @return Void-promise that resolves when end-handler has processed the
     *         end-of-stream
     */
    Stream.prototype.end = function (error, endedResult) {
        if (!(error === undefined || error === null || error instanceof Error)) {
            return ts_promise_1.Promise.reject(new TypeError("invalid argument to end(): must be undefined, null or Error object"));
        }
        if (error && !endedResult) {
            endedResult = ts_promise_1.Promise.reject(error);
        }
        var eof = new Eof(error, endedResult);
        if (!this._ending && !this._ended) {
            this._ending = eof;
        }
        var valuePromise = ts_promise_1.Promise.resolve(eof);
        var writeDone = ts_promise_1.Promise.defer();
        this._writers.push({
            resolveWrite: writeDone.resolve,
            value: valuePromise,
        });
        this._pump();
        return writeDone.promise;
    };
    /**
     * Read all values from stream, optionally waiting for explicit stream end.
     *
     * `reader` is called for every written value.
     *
     * `ender` is called once, when the writer `end()`s the stream, either with
     * or without an error.
     *
     * `aborter` is called once if the stream is aborted and has not ended yet.
     *
     * `reader` and `ender` callbacks can return a promise to indicate when the
     * value or end-of-stream condition has been completely processed. This
     * ensures that a fast writer can never overload a slow reader, and is
     * called 'backpressure'.
     *
     * The corresponding `write()` or `end()` operation is blocked until the
     * value returned from the reader or ender callback is resolved. If the
     * callback throws an error or the returned promise resolves to a rejection,
     * the `write()` or `end()` will be rejected with it.
     *
     * All callbacks are always called asynchronously (i.e. some time
     * after `forEach()`, `write()`, `end()` or `abort()` returns), and their
     * `this` argument will be undefined.
     *
     * The `reader` and `ender` callbacks are never called again before their
     * previously returned promise is resolved/rejected.
     *
     * The `aborter` callback can be called while a reader callback's promise is
     * still pending, and should try to let `reader` or `ender` finish as fast
     * as possible. It will not be called after the output of `ender` has
     * resolved.
     *
     * If no `ender` is given, a default end handler is installed that returns
     * any stream end errors to the writer, and otherwise directly acknowledges
     * the end-of-stream.
     *
     * It is an error to call `forEach()` multiple times.
     *
     * @param reader  Callback called with every written value
     * @param ender   Optional callback called when stream is ended
     * @param aborter Optional callback called when stream is aborted
     */
    Stream.prototype.forEach = function (reader, ender, aborter) {
        if (this.hasReader()) {
            return ts_promise_1.Promise.reject(new AlreadyHaveReaderError());
        }
        if (!ender) {
            ender = defaultEnder;
        }
        this._reader = reader;
        this._ender = ender;
        this._aborter = aborter;
        this._pump();
        return this.result();
    };
    /**
     * Signal stream abort.
     *
     * If an `aborter` callback is set by `forEach()` and the stream has not
     * ended yet, it will (asynchronously) be called with the abort reason, to
     * allow early termination of pending operation(s).
     *
     * If a reader is currently processing a value (i.e. a promise returned from
     * a read callback is not resolved yet), that operation is still allowed to
     * complete (although it can e.g. be cancelled by the `aborter` callback
     * to `forEach()`).
     *
     * Any pending and future `write()`s after that will be rejected with the
     * given error.
     *
     * The stream is not ended until the writer explicitly `end()`s the stream,
     * after which the stream's `ender` callback is called with the abort error
     * (i.e. any error passed to `end()` is ignored).
     *
     * The abort is ignored if the stream is already aborted.
     * Note that it's possible to abort an ended stream, to allow the abort to
     * 'bubble' to other parts in a chain of streams, which may not have ended
     * yet. It will not change the end-state of this part of the stream though.
     *
     * @param reason Error value to signal a reason for the abort
     */
    Stream.prototype.abort = function (reason) {
        if (this._abortPromise) {
            return;
        }
        this._abortDeferred.reject(reason);
        this._abortPromise = this._abortDeferred.promise;
        this._pump();
    };
    /**
     * Obtain promise that resolves to a rejection when `abort()` is called.
     *
     * Useful to pass abort to up- and down-stream sources.
     *
     * @return Promise that is rejected with abort error when stream is aborted
     */
    Stream.prototype.aborted = function () {
        return this._abortDeferred.promise;
    };
    /**
     * Obtain a promise that resolves when the stream has completely ended:
     * - `end()` has been called (possibly with an Error),
     * - `ender` callback has run and its returned promise resolved,
     * - `end()`'s result parameter (if any) has been resolved.
     *
     * @return Promise resolved when stream has completely ended
     */
    Stream.prototype.result = function () {
        return this._resultDeferred.promise;
    };
    /**
     * Determine whether `end()` has been called on the stream, but the stream
     * is still processing it.
     *
     * @return true when `end()` was called but not acknowledged yet, false
     *         otherwise
     */
    Stream.prototype.isEnding = function () {
        return !!this._ending;
    };
    /**
     * Determine whether stream has completely ended (i.e. end handler has been
     * called and its return Thenable, if any, is resolved).
     * @return true when stream has ended, false otherwise
     */
    Stream.prototype.isEnded = function () {
        return !!this._ended;
    };
    /**
     * Determine whether `end()` has been called on the stream.
     *
     * @return true when `end()` was called
     */
    Stream.prototype.isEndingOrEnded = function () {
        return this.isEnding() || this.isEnded();
    };
    /**
     * Determine whether `forEach()` callback(s) are currently attached to the
     * stream.
     *
     * @return true when `forEach()` has been called on this stream
     */
    Stream.prototype.hasReader = function () {
        return !!this._reader;
    };
    /**
     * Run all input values through a mapping callback, which must produce a new
     * value (or promise for a value), similar to e.g. `Array`'s `map()`.
     *
     * Stream end in the input stream (normal or with error) will be passed to
     * the output stream, after awaiting the result of the optional ender.
     *
     * Any error (thrown or rejection) in mapper or ender is returned to the
     * input stream.
     *
     * @param mapper  Callback which receives each value from this stream, and
     *                must produce a new value (or promise for a value)
     * @param ender   Called when stream is ending, result is waited for before
     *                passing on `end()`
     * @param aborter Called when stream is aborted
     * @return New stream with mapped values
     */
    Stream.prototype.map = function (mapper, ender, aborter) {
        var output = new Stream();
        Transform_1.map(this, output, mapper, ender, aborter);
        return output;
    };
    /**
     * Run all input values through a filtering callback. If the filter callback
     * returns a truthy value (or a promise for a truthy value), the input value
     * is written to the output stream, otherwise it is ignored.
     * Similar to e.g. `Array`'s `filter()`.
     *
     * Stream end in the input stream (normal or with error) will be passed to
     * the output stream, after awaiting the result of the optional ender.
     *
     * Any error (thrown or rejection) in mapper or ender is returned to the
     * input stream.
     *
     * @param filterer Callback which receives each value from this stream,
     *                 input value is written to output if callback returns a
     *                 (promise for) a truthy value.
     * @param ender    Called when stream is ending, result is waited for before
     *                 passing on `end()`
     * @param aborter  Called when stream is aborted
     * @return New stream with filtered values.
     */
    Stream.prototype.filter = function (filterer, ender, aborter) {
        var output = new Stream();
        Transform_1.filter(this, output, filterer, ender, aborter);
        return output;
    };
    /**
     * Reduce the stream into a single value by calling a reducer callback for
     * each value in the stream. Similar to `Array#reduce()`.
     *
     * The output of the previous call to `reducer` (aka `accumulator`) is given
     * as the first argument of the next call. For the first call, either the
     * `initial` value to `reduce()` is passed, or the first value of the stream
     * is used (and `current` will be the second value).
     *
     * The result of `reduce()` is a promise for the last value returned by
     * `reducer` (or the initial value, if there were no calls to `reducer`).
     * If no initial value could be determined, the result is rejected with a
     * TypeError.
     * If the stream is ended with an error, the result is rejected with that
     * error.
     *
     * It is possible for `reducer` to return a promise for its result.
     *
     * If the `reducer` throws an error or returns a rejected promise, the
     * originating `write()` will fail with that error.
     *
     * Examples:
     * s.reduce((acc, val) => acc + val); // sums all values
     * s.reduce((acc, val) => { acc.push(val); return acc; }, []); // toArray()
     *
     * @param  reducer Callback called for each value in the stream, with
     *                 accumulator, current value, index of current value, and
     *                 this stream.
     * @param  initial Optional initial value for accumulator. If no initial
     *                 value is given, first value of stream is used.
     * @return Promise for final accumulator.
     */
    Stream.prototype.reduce = function (reducer, initial) {
        var _this = this;
        var haveAccumulator = arguments.length === 2;
        var accumulator = initial;
        var index = 0;
        return this.forEach(function (value) {
            if (!haveAccumulator) {
                accumulator = value;
                haveAccumulator = true;
                index++;
            }
            else {
                return ts_promise_1.Promise.resolve(reducer(accumulator, value, index++, _this))
                    .then(function (newAccumulator) { return accumulator = newAccumulator; });
            }
        }).then(function () {
            if (!haveAccumulator) {
                return ts_promise_1.Promise.reject(new TypeError("cannot reduce() empty stream without initial value"));
            }
            return accumulator;
        });
    };
    /**
     * Read all stream values into an array.
     *
     * Returns a promise that resolves to that array if the stream ends
     * normally, or to the error if the stream is ended with an error.
     *
     * @return Promise for an array of all stream values
     */
    Stream.prototype.toArray = function () {
        var result = [];
        return this.forEach(function (value) { result.push(value); })
            .return(result);
    };
    /**
     * Read all values and end-of-stream from this stream, writing them to
     * `writable`.
     *
     * @param  writable Destination stream
     * @return The stream passed in, for easy chaining
     */
    Stream.prototype.pipe = function (writable) {
        var _this = this;
        writable.aborted().catch(function (err) { return _this.abort(err); });
        this.aborted().catch(function (err) { return writable.abort(err); });
        this.forEach(function (value) { return writable.write(value); }, function (error) { return writable.end(error, _this.result()); });
        return writable;
    };
    /**
     * Return a new stream with the results of running the given
     * transform.
     *
     * @param transformer Function that receives this stream and result stream
     *                    as inputs.
     * @return Readable stream with the transformed results
     */
    Stream.prototype.transform = function (transformer) {
        var output = new Stream();
        transformer(this, output);
        return output;
    };
    /**
     * Repeatedly call `writer` and write its returned value (or promise for it)
     * to the stream.
     * The stream is ended when `writer` returns `undefined`.
     *
     * `writer` is only called when its previously returned value has been
     * processed by the stream.
     *
     * If writing of a value fails (either by the callback throwing an error,
     * returning a rejection, or the write call failing), the stream is aborted
     * and ended with that error.
     *
     * If ending of the stream fails with an error other than the abort error,
     * the program is terminated with an UnhandledEndError.
     *
     * NOTE Whether stream is aborted on error is still subject to change.
     *
     * @param writer Called when the next value can be written to the stream,
     *               should return (a promise for) a value to be written,
     *               or `undefined` (or void promise) to end the stream.
     * @return Stream for all values in the input array
     */
    Stream.prototype.writeEach = function (writer) {
        var _this = this;
        this.aborted().catch(function (abortError) {
            // Swallow errors from the end call, as they will be reflected in
            // result() too
            util_1.swallowErrors(_this.end(abortError));
        });
        var loop = function () {
            if (_this._abortPromise) {
                // Don't call writer when aborted
                return;
            }
            var valuePromise = writer();
            return ts_promise_1.Promise.resolve(valuePromise).then(function (value) {
                if (value === undefined) {
                    return _this.end();
                }
                else {
                    return _this.write(value).then(loop);
                }
            });
        };
        ts_promise_1.Promise.resolve().then(loop).done(undefined, function (error) { return _this.abort(error); });
        return this.result();
    };
    // TODO Experimental
    // TODO Not sure whether a 'reverse' function confuses more than it helps
    Stream.prototype.mappedBy = function (mapper) {
        var input = new Stream();
        Transform_1.map(input, this, mapper);
        return input;
    };
    // TODO Experimental
    // TODO Not sure whether a 'reverse' function confuses more than it helps
    Stream.prototype.filterBy = function (filterer) {
        var input = new Stream();
        Transform_1.filter(input, this, filterer);
        return input;
    };
    /**
     * Return a Stream for all values in the input array.
     *
     * The stream is ended as soon as the first `undefined` value is
     * encountered.
     *
     * The array itself, and/or the values in the array can also be promises.
     *
     * @see result() to wait for completion
     * @see writeEach() for error handling behavior
     *
     * @param data (Promise for) input array of (promises for) values
     * @return Stream of all values in the input array
     */
    Stream.from = function (data) {
        var stream = new Stream();
        var i = 0;
        if (Array.isArray(data)) {
            stream.writeEach(function () { return data[i++]; });
        }
        else {
            ts_promise_1.Promise.resolve(data).then(function (resolvedArray) {
                stream.writeEach(function () { return resolvedArray[i++]; });
            });
        }
        return stream;
    };
    /**
     * Pump written values to `_reader` and `_ender`, resolve results of
     * `write()` and `end()`.
     */
    Stream.prototype._pump = function () {
        // Call abort handler, if necessary
        if (this._abortPromise && this._aborter) {
            // Make sure to call it asynchronously, and without a 'this'
            // TODO: can any error thrown from the aborter be handled?
            util_1.swallowErrors(this._abortPromise.catch(this._aborter));
            this._aborter = undefined;
        }
        // If waiting for a reader/ender, wait some more or handle it
        if (this._readBusy) {
            if (this._readBusy.isPending()) {
                // Pump is already attached to _readBusy, so just wait for that
                // to be resolved
                return;
            }
            // Previous reader/ender has resolved, return its result to the
            // corresponding write() or end() call
            this._writers.shift().resolveWrite(this._readBusy);
            if (this._endPending) {
                var result_1 = this._endPending.result;
                this._ended = this._endPending.error || EOF;
                this._ending = undefined;
                this._endPending = undefined;
                this._aborter = undefined; // no longer call aborter after end handler has finished
                var p = result_1 ? this._readBusy.then(function () { return result_1; }) : this._readBusy;
                this._resultDeferred.resolve(p);
            }
            this._readBusy = undefined;
        }
        // If ended, reject any pending and future writes/ends with an error
        if (this._ended) {
            while (this._writers.length > 0) {
                var writer_1 = this._writers.shift();
                writer_1.resolveWrite(ts_promise_1.Promise.reject(new WriteAfterEndError()));
            }
            return;
        }
        // In case we're aborting, abort all pending and future write()'s (i.e.
        // not the end()'s)
        if (this._abortPromise) {
            while (this._writers.length > 0) {
                var writer_2 = this._writers[0];
                var value_1 = writer_2.value.isFulfilled() && writer_2.value.value();
                if (value_1 instanceof Eof) {
                    break;
                }
                // Reject all non-end write()'s with abort reason
                util_1.swallowErrors(writer_2.value);
                writer_2.resolveWrite(this._abortPromise);
                this._writers.shift();
            }
        }
        // Wait until at least one value and a reader are available
        if (this._writers.length === 0 || !this._reader) {
            // write(), end() and forEach() will pump us again
            return;
        }
        var writer = this._writers[0];
        // Wait until next written value is available
        // (Note: when aborting, all non-end() writers will already have been
        // aborted above, and an Eof is a resolved value)
        if (writer.value.isPending()) {
            writer.value.done(this._pumper, this._pumper);
            return;
        }
        // If written value resolved to a rejection, make its write() fail
        if (writer.value.isRejected()) {
            writer.resolveWrite(writer.value);
            this._writers.shift();
            // Pump again
            ts_promise_1.Promise.resolve().done(this._pumper);
            return;
        }
        // Determine whether we should call the reader or the ender.
        // Handler is always asynchronously called, and by chaining it from
        // the writer's value, long stack traces are maintained.
        var value = writer.value.value();
        if (value instanceof Eof) {
            // EOF, with or without error
            assert(!this._ended && !this._endPending);
            this._endPending = value;
            var ender_1 = this._ender; // Ensure calling without `this`
            this._ender = undefined; // Prevent calling again
            // Call with end error or override with abort reason if any
            var enderArg_1 = this._abortPromise ? this._abortPromise.reason() : value.error;
            this._readBusy = writer.value.then(function (eofValue) { return ender_1(enderArg_1); });
        }
        else {
            this._readBusy = writer.value.then(this._reader);
        }
        this._readBusy.done(this._pumper, this._pumper);
    };
    return Stream;
}());
exports.Stream = Stream;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Stream;
//# sourceMappingURL=Stream.js.map